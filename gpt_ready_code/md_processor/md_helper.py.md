"md_helper.py": "'from typing import Optional\nimport glob\nimport pyperclip\nimport os\nimport re\nimport subprocess\nimport time\nimport file_operations_utils\ndef text_replace(root_dir: str, replace_list: list):\n\tassets_root_path, assets_root_dir = get_assets_root_path()\n\toutput_dir = create_output_directory(assets_root_path)\n\tfor filename_with_ext in os.listdir(root_dir):\n\t\tif filename_with_ext.endswith(\'.md\'):\n\t\t\tsrc_path = os.path.join(root_dir, filename_with_ext)\n\t\t\tdest_path = os.path.join(output_dir, filename_with_ext)\n\t\t\twith open(src_path, \'r\', encoding=\'UTF-8\') as f_src, open(dest_path, \'w\', encoding=\'UTF-8\') as f_dest:\n\t\t\t\tfor line in f_src:\n\t\t\t\t\tfor replace_item in replace_list:\n\t\t\t\t\t\tline = line.replace(replace_item[0], replace_item[1])\n\t\t\t\t\tf_dest.write(line)\ndef mdx2md(timestamp: int = 1676880280):\n\tassets_root_path, assets_root_dir = get_assets_root_path()\n\toutput_dir = create_output_directory(assets_root_path)\n\tcwd = os.getcwd()\n\t# text_replace_list_mdx2md3 = [\n\t#\t\t\t\t\t\t\t  ]\n\t# replace_list = text_replace_list_mdx2md3\n\t# <Figure\n\tfor filename_with_ext in os.listdir(cwd):\n\t\tif filename_with_ext.endswith(\'.md\'):\n\t\t\tsrc_path = os.path.join(cwd, filename_with_ext)\n\t\t\tdest_path = os.path.join(output_dir, filename_with_ext)\n\t\t\t# with open(src_path, \'r\', encoding=\'UTF-8\') as f_src, open(dest_path, \'w\', encoding=\'UTF-8\') as f_dest:\n\t\t\t#\t for line in f_src:\n\t\t\t#\t\t for replace_item in replace_list:\n\t\t\t#\t\t\t line = line.replace(replace_item[0], replace_item[1])\n\t\t\t#\t\t f_dest.write(line)\n\t\t\twith open(src_path, \'r\', encoding=\'UTF-8\') as f_src:\n\t\t\t\tcontent = f_src.read()\n\t\t\t# Define the regex pattern and replacement string\n\t\t\treplace_list_regex = [\n\t\t\t\t\t\t\t\t [r"<PiCreature\\n{0,}\\s{0,}(.+)\\n{0,}\\s{0,}(.+)\\n{0,}\\s{0,}/>", r"\\1\\n\\2\\n"],\n\t\t\t\t# [r"show=\\"video\\"\\n", r""],\n\t\t\t\t#  [r"<!--", r""],\n\t\t\t\t#  [r"-->", r""],\n\t\t\t\t\t\t\t\t [r"<Question", r"---"],\n\t\t\t\t\t\t\t\t [r"<FreeResponse>", r"---"],\n\t\t\t\t[r"</FreeResponse>", r"---"],\n\t\t\t\t[r"</Question>", r"---"],\n\t\t\t\t[r\'\'\'<Figure[\\n ]{1,}image="(.+)(\\.svg|\\.png|\\.jpg)"[\\w ._="\'\\n_%]{0,}/>\'\'\',\n\t\t\t\t\t\t\t\t\t r\'![](\\1_\'+str(timestamp)+r\'\\2)\'],\n\t\t\t\t[r\'<Accordion\\stitle=".+">\\n\', r\'\'],\n\t\t\t\t[r\'</Accordion>\\n\', r\'\'],\n\t\t\t\t# [r\'emotion="\\w+"[ \\t]+\\n\', r\'\'],\n\t\t\t\t# [r\'flip=\\{(true|false)\\}\\n\', r\'\'],\n\t\t\t\t# [r\'(?s)<Question .+?</Question>\', r\'tttttttttttttttttttt\'],\n\t\t\t\t[r\'answer=\\{(\\d)\\}[ \\n\\t]{0,}>\',\n\t\t\t\t\t\t\t\t\t r\'\\n<details><summary>answer</summary><p>Choice= \\1</p></details>\\n\\n- **Explanation**\'],\n\t\t\t\t# [r\'\'\'<Question[\\n \\t]{0,}question="(.+)"[\\n \\t]{0,}choice1="(.+)"[\\n \\t]{0,}choice2="(.+)"[\\n \\t]{0,}choice3="(.+)"[\\n \\t]{0,}choice4="(.+)"[\\n \\t]answer=\\{(\\d)\\}[\\n \\t]{0,}>\'\'\',r\'- **Question**\\n\\t\\1\']\n\t\t\t\t[r\'[ \\t]{0,}question="(.+)"\',\n\t\t\t\t\t\t\t\t\t r\'- **Question**\\n\\t\\1\'],\n\t\t\t\t[r\'[ \\t]{0,}choice1="(.+)"\',\n\t\t\t\t\t\t\t\t\t r\'\t- **Choice 1=** \\1\'],\n\t\t\t\t[r\'[ \\t]{0,}choice2="(.+)"\',\n\t\t\t\t\t\t\t\t\t r\'\t- **Choice 2=** \\1\'],\n\t\t\t\t[r\'[ \\t]{0,}choice3="(.+)"\', r\'\t- **Choice 3=** \\1\'],\n\t\t\t\t[r\'[ \\t]{0,}choice4="(.+)"\', r\'\t- **Choice 4=** \\1\'],\n\t\t\t\t# [r\'video=".+\\.mp4"\', r\'\'],\n\t\t\t\t# [r\'show="video"\', r\'\'],\n\t\t\t\t[r\'([ \\t]{0,}\\n){3,}\', r\'\\1\\1\'],\n\t\t\t\t# [\'/>\', r\'\'],\n\t\t\t]\n\t\t\tfor i in range(len(replace_list_regex)):\n\t\t\t\tpattern = replace_list_regex[i][0]\n\t\t\t\treplacement = replace_list_regex[i][1]\n\t\t\t\t# Perform the regex replacement\n\t\t\t\tcontent = re.sub(pattern, replacement, content)\n\t\t\t# Write the modified content to the output Markdown file with UTF-8 encoding\n\t\t\twith open(dest_path, \'w\', encoding=\'utf-8\') as file:\n\t\t\t\tfile.write(content)\ndef remove_back_matter_and_copy_code(directory_path=None):\n\tif directory_path is None:\n\t\tdirectory_path = os.getcwd()\n\tfiles_md = [f for f in os.listdir(directory_path) if f.endswith(\'.md\')]\n\treg_string_list = []\n\treg_Back_matter_template = [r"---\\n\\n- created:.+\\n- source: .+", r""]\n\treg_string_list.extend([reg_Back_matter_template])\n\treg_string_copy_code = [r"```\\n(.+)Copy code", r"```\\1\\n"]\n\treg_string_list.extend([reg_string_copy_code])\n\tfile_operations_utils.perform_regex_replacement_on_files(\n\t\treg_string_list, directory_path, files_md)\ndef Is_head_line(line):\n\tpattern = r"^(#{1,}) (.+|)"\n\tmatch = re.search(pattern, line)\n\tif match:\n\t\treturn True\n\telse:\n\t\treturn False\ndef get_highest_head_level(content):\n\tlines = content.split(\'\\n\')\n\tlowest_level = float(\'inf\')\n\tpattern = re.compile(r"^(#{1,}) ")\n\tfor line in lines:\n\t\tmatch = pattern.match(line)\n\t\tif match:\n\t\t\tlevel = len(match.group(1))\n\t\t\tif level < lowest_level:\n\t\t\t\tlowest_level = level\n\treturn lowest_level if lowest_level != float(\'inf\') else None\ndef downgrade_heads(content, downgrade_level):\n\tlines = content.split(\'\\n\')\n\tnew_lines = []\n\tfor line in lines:\n\t\tif Is_head_line(line):\n\t\t\thead_level = 0\n\t\t\tfor char in line:\n\t\t\t\tif char == \'#\':\n\t\t\t\t\thead_level += 1\n\t\t\t\telse:\n\t\t\t\t\tbreak\n\t\t\tif head_level > 0:\n\t\t\t\tnew_head_level = head_level + downgrade_level\n\t\t\t\tif new_head_level > 6:\n\t\t\t\t\tnew_head_level = 6\n\t\t\t\tnew_line = \'#\' * new_head_level + line[head_level:]\n\t\t\t\tnew_lines.append(new_line)\n\t\telse:\n\t\t\tnew_lines.append(line)\n\treturn \'\\n\'.join(new_lines)\ndef upgrade_heads(content, upgrade_level):\n\tlines = content.split(\'\\n\')\n\tnew_lines = []\n\tfor line in lines:\n\t\thead_level = 0\n\t\tfor char in line:\n\t\t\tif char == \'#\':\n\t\t\t\thead_level += 1\n\t\t\telse:\n\t\t\t\tbreak\n\t\tif head_level > 0:\n\t\t\tnew_head_level = head_level - upgrade_level\n\t\t\tif new_head_level < 1:\n\t\t\t\tnew_head_level = 1\n\t\t\tnew_line = \'#\' * new_head_level + line[head_level:]\n\t\t\tnew_lines.append(new_line)\n\t\telse:\n\t\t\tnew_lines.append(line)\n\treturn \'\\n\'.join(new_lines)\ndef degrade_markdown_by_head_number(head_number):\n\tcontent = pyperclip.paste()\n\tTR_MODE = 1\n\thighest_head_level = get_highest_head_level(content)\n\t# highest_head_level=3\n\tif TR_MODE:\n\t\tprint("highest_head_level: ", highest_head_level)\n\t\tprint("head_number: ", head_number)\n\tif highest_head_level < head_number:\n\t\tcontent = downgrade_heads(\n\t\t\tcontent, head_number-highest_head_level)\n\t\tpyperclip.copy(content)\ndef upgrade_markdown_by_head_number(head_number):\n\tcontent = pyperclip.paste()\n\tTR_MODE = 1\n\thighest_head_level = get_highest_head_level(content)\n\tif TR_MODE:\n\t\tprint("highest_head_level: ", highest_head_level)\n\t\tprint("head_number: ", head_number)\n\tif highest_head_level > head_number:\n\t\tcontent = upgrade_heads(\n\t\t\tcontent, highest_head_level-head_number)\n\t\tpyperclip.copy(content)\ndef process_md_head_to_hn(head_number, content=None):\n\tif content is None:\n\t\tcontent = pyperclip.paste()\n\tTR_MODE = 1\n\thighest_head_level = get_highest_head_level(content)\n\tif TR_MODE:\n\t\tprint("highest_head_level: ", highest_head_level)\n\t\tprint("head_number: ", head_number)\n\tif highest_head_level > head_number:\n\t\tcontent = upgrade_heads(\n\t\t\tcontent, highest_head_level-head_number)\n\t\tpyperclip.copy(content)\n\telif highest_head_level < head_number:\n\t\tcontent = downgrade_heads(\n\t\t\tcontent, head_number-highest_head_level)\n\t\tpyperclip.copy(content)\ndef format_2_gpt_input(content=None):\n\t"""\n\tThis function formats the input content by replacing one or more newline characters with a single newline character.\n\tIf no content is provided, it fetches the content from the clipboard, formats it, and then copies the formatted content back to the clipboard.\n\t:param content: The input content to format. If None, the content will be taken from the clipboard.\n\t"""\n\tif content is None:\n\t\tcontent = pyperclip.paste()\n\t# content = repr(content)\n\tprint(repr(content))\n\tcontent = content.replace("\\r\\n", "\\n")\n\tcontent = content.replace("\n", "\\n")\n\treg_repalce_list = []\n\treg_repalce_list.append([r"\\n{2,}", r"\\n"])\n\treg_repalce_list.append([r"[ ]{2,}", " "])\n\tfor reg_replace in reg_repalce_list:\n\t\tcontent = re.sub(reg_replace[0], reg_replace[1], content)\n\t# Printing the formatted content\n\tprint(repr(content))\n\t# Copying the formatted content back to the clipboard\n\tpyperclip.copy(repr(content))\ndef mermaid_format(content=None):\n\tif content is None:\n\t\tcontent = pyperclip.paste()\n\t# content = repr(content)\n\tprint(repr(content))\n\t# content = content.replace(" \\w{1,3}", "\\n")\n\tnum_str = r"22"\n\treg_repalce_list = []\n\treg_repalce_list.append(\n\t\t[r" (\\w{1,3})( |\\n|\\(|\\{|\\[)", r" \\1_"+num_str+r"\\2"])\n\t# reg_repalce_list.append([r" \\w{1,3}\\n", r" \\1\\n"+num_str])\n\tfor reg_replace in reg_repalce_list:\n\t\tcontent = re.sub(reg_replace[0], reg_replace[1], content)\n\tprint(repr(content))\n\t# Copying the formatted content back to the clipboard\n\tpyperclip.copy(content)\ndef retrieve_document_summary_info(content=None):\n\tif content is None:\n\t\tcontent = pyperclip.paste()\n\treg_string1 = [\n\t\tr\'(#{1,6}) (.+)\\n\\n<video src="file://.+" controls></video>\\n\\n- .+\', r"\\1# \\2"]\n\tmatch = re.search(reg_string1[0], content)\n\tif match:\n\t\tcontent = re.sub(reg_string1[0], reg_string1[1], content)\n\treg_string2 = [r\'\\n{3,}\', r\'\\n\\n\']\n\tcontent = re.sub(reg_string2[0], reg_string2[1], content)\n\tpyperclip.copy(content)\ndef format_ocr_text(content=None):\n\tTR_mode = False\n\tif content is None:\n\t\tcontent = pyperclip.paste()\n\tif TR_mode:\n\t\tprint(":", repr(content))\n\tcontent = content.replace(\'\\n\', \' \')\n\tcontent = content.replace(\'\\r\', \' \')\n\tif TR_mode:\n\t\tprint(repr(content))\n\twhile \'  \' in content:\n\t\tcontent = content.replace(\'  \', \' \')\n\tif TR_mode:\n\t\tprint(repr(content))\n\tpyperclip.copy(content)\ndef create_file_based_on_content(content=None, path=None):\n\t"""\n\tThis function creates a file based on the content provided.\n\tParameters:\n\tcontent (str): The content to be written to the file. If not provided, it will use the content from the clipboard.\n\tpath (str): The path where the file will be created. If not provided, it will use the current working directory.\n\tRaises:\n\tValueError: If the length of the content is less than 1 or greater than 100.\n\tTypeError: If the content contains more than 2 newline characters.\n\t"""\n\tif content is None:\n\t\tcontent = pyperclip.paste()\n\tif path is None:\n\t\tpath = os.getcwd()\n\tif len(content) > 100:\n\t\traise ValueError("Content length exceeds 100 characters")\n\tif len(content) < 1:\n\t\traise ValueError("Content length is less than 1 character")\n\tif content.count("\\n") > 2:\n\t\traise TypeError("Content contains more than 2 newline characters")\n\tcontent = content.replace(\'\\n\', \' \')\n\tcontent = content.replace(\'\\r\', \' \')\n\treg = [r"\\s{2,}", r\' \']\n\tcontent = re.sub(reg[0], reg[1], content)\n\ttimestamp = str(int(time.time()))\n\tnew_name = content.strip() + "_" + timestamp + ".md"\n\twith open(os.path.join(path, new_name), "w", encoding="utf-8") as file:\n\t\tfile.write("")\ndef create_node_for_mermaid(num=30):\n\tcontent = ""\n\tfor i in range(num):\n\t\tcontent += f"Node{i+1}[\\"\\"]\\n"\n\tpyperclip.copy(content)\ndef main():\n\tcontent = pyperclip.paste()\n\thighest_level = get_highest_head_level(content)\n\tprint(f"The highest head level is {highest_level}")\n\tdowngrade_level = int(\n\t\tinput("Enter the number by which you want to downgrade the headers: "))\n\tnew_content = downgrade_heads(content, downgrade_level)\n\tpyperclip.copy(new_content)\n\tprint("Content updated in clipboard.")\nif __name__ == "__main__":\n\tmain()\n'",
